@using Boutique.Client.Services
@inject CustomerMeasurementService MeasurementService

<div class="form-floating mb-3">
    <input type="number" class="form-control @(IsValid ? "" : "is-invalid")" 
           value="@Value" @onchange="OnValueChanged" step="0.1" placeholder="@Label" />
    <label>@Label (@MinValue-@MaxValue inches)</label>
    @if (!IsValid && !string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="invalid-feedback d-block">@ErrorMessage</div>
    }
</div>

@code {
    [Parameter] public string Label { get; set; } = "";
    [Parameter] public string Gender { get; set; } = "";
    [Parameter] public string MeasurementType { get; set; } = "";
    [Parameter] public decimal MinValue { get; set; }
    [Parameter] public decimal MaxValue { get; set; }
    [Parameter] public double Value { get; set; }
    [Parameter] public EventCallback<double> ValueChanged { get; set; }
    [Parameter] public EventCallback<bool> ValidationChanged { get; set; }

    private bool IsValid = true;
    private string ErrorMessage = "";

    private async Task OnValueChanged(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var value))
        {
            Value = value;
            await ValueChanged.InvokeAsync(Value);
            
            // Simple range validation - only validate if value > 0
            if (value > 0 && (value < (double)MinValue || value > (double)MaxValue))
            {
                IsValid = false;
                ErrorMessage = $"Value must be between {MinValue} and {MaxValue} inches";
                await ValidationChanged.InvokeAsync(false);
            }
            else
            {
                IsValid = true;
                ErrorMessage = "";
                await ValidationChanged.InvokeAsync(true);
            }
            
            StateHasChanged();
        }
    }
}